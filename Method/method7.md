# 《Question Decomposition-Augmented RAG with Reranking for Multi-Hop QA》
论文针对传统检索增强生成（RAG）在多跳查询中因证据分散导致的检索覆盖不足、噪声干扰等问题，提出**问题分解增强型RAG（QD-RAG）** 框架。该方法通过“问题分解（QD）模块”拆分复杂查询以扩大证据覆盖，结合“跨编码器重排序（Reranking）模块”过滤噪声，形成“分解-检索-聚合-重排-生成”的闭环优化，高效解决多跳推理场景下的检索与生成痛点。以下内容均源自目标论文，严格遵循原方法逻辑与实验结论。
-Paul J. L. Ammann, Jonas Golde, Alan Akbik. Question Decomposition for Retrieval-Augmented Generation[J]. arXiv preprint arXiv:2507.00355, 2025.

## 一、核心概念与方法框架
QD-RAG的核心是通过**查询分解与重排序协同**打破传统RAG“单查询检索”的局限，框架包含两大核心模块，关键概念与流程定义如下（论文3.1-3.2节）：

### 1. 核心概念
- **多跳查询（Multi-hop Query）**：需关联多个分散证据才能回答的复杂查询，支持事实分布于多篇文档（如“NVIDIA、Apple、Google中哪家2023年利润最高？”）。
- **问题分解（QD）模块**：基于指令调优LLM，将原复杂查询拆分为多个聚焦子查询，无需任务特定训练，确保每个子查询对应单一证据维度。
- **重排序（Reranking）模块**：采用预训练跨编码器，基于原查询对聚合后的候选文档打分，过滤“对子查询相关但对原查询无关”的噪声。
- **候选集聚合（Candidate Pool Aggregation）**：合并所有子查询的检索结果并去重，形成覆盖多维度证据的候选集合，解决单查询覆盖不足问题。

### 2. 方法框架流程
QD-RAG的完整流程分为**检索增强阶段**与**生成阶段**，逻辑如下（论文3.1节、Algorithm 1）：
1. **检索增强阶段（QD+Reranking主导）**：
   - $$输入原查询\(q\)与文档 corpus\(D\)$$；
   - $$QD模块生成子查询集合({{q}_1,...,{q}_n\})，与原查询组成检索查询集\(Q=\{q\} \cup \{{q}_1,...,{q}_n\}\)$$；
   - $$对每个查询\(q_i \in Q\)$$检索top-k文档，聚合去重得到候选集\(C\)$$；
   - 重排序模块对\(C\)打分，筛选top-k高相关文档\(R'(q)\)；
2. **生成阶段**：
   - $$将原查询\(q\)与\(R'(q)\)拼接为输入序列$$；
   - 生成模型基于拼接内容生成答案，实现“全量覆盖+精准降噪”。

## 二、数学公式与符号定义
论文通过严格数学定义规范QD-RAG的核心计算逻辑，以下为关键公式与符号说明（论文2-3节）：

### 1. 符号约定
| 符号          | 含义说明                                  | 示例                          |
|---------------|-------------------------------------------|-------------------------------|
| \(q\)         | 原复杂查询                                | “Which company among NVIDIA, Apple, and Google made the biggest profit in 2023?” |
| \$$(Q=\{q\} \cup \{\tilde{q}_1,...,\tilde{q}_n\}\$$) | 检索查询集（含原查询与子查询） | \(\$${q, \text{“2023年NVIDIA利润”}, \text{“2023年Apple利润”}\}$$\) |
| \(D\)         | 文档语料库                                | Wikipedia全量文档集合         |
| \(C\)         | 聚合后的候选文档集                        | 所有子查询检索结果去重后集合  |
| \$$(g_{\phi}(q, d)\$$) | 跨编码器重排序得分（\$$(\phi\)$$为模型参数） | 0.92（高相关）、0.31（低相关） |
| \(R'(q)\)     | 重排序后的最终检索文档集                  | top-10高相关文档              |
| \(k\)         | 检索与重排序的文档数量阈值                | 10（论文最优值）              |

### 2. QD：查询分解与候选集聚合
#### （1）子查询生成
QD模块通过固定指令提示函数\(DECOMPOSE(q, p)\)生成子查询，数学表达为：
$$\{\tilde{q}_1,...,\tilde{q}_n\} = DECOMPOSE(q, p)$$
- \(p\)：固定指令（如“将复杂问题拆分为可直接检索的简单子问题”）；
- \(n\)：子查询数量（论文限制最多5个，确保检索效率）。

#### （2）候选集聚合
对每个查询\(q_i \in Q\)检索top-k文档，聚合去重得到候选集：
$$C = \bigcup_{q_i \in Q} TOP-K(q_i, D)$$
- $$\(TOP-K(q_i, D)\)：子查询\(q_i\)的top-k检索结果$$；
- 聚合时自动去重，避免重复文档占用计算资源。

### 3. Reranking：重排序与最终检索集筛选
#### （1）重排序得分计算
跨编码器对“原查询-候选文档”对联合编码，输出相关性得分：
$$score(q, d) = g_{\phi}(q, d)$$
- $$\(g_{\phi}\)：预训练跨编码器（论文采用bge-reranker-large）$$；
- 得分越高表示文档与原查询语义关联越强。

#### （2）最终检索集生成
按得分降序排序，选取top-k文档作为生成阶段输入：
$$R'(q) = HEAD(\text{SORT}(C, score(q, d)), k)$$
- $$\(\text{SORT}(C, score(q, d))\)：按重排序得分对候选集排序$$；
- $$\(HEAD(\cdot, k)\)：选取前k个文档$$。

### 4. 生成阶段输入构造
生成模型的输入为原查询与最终检索集的拼接序列：
$$x = [q; d_1; d_2; ... ; d_k], \quad d_i \in R'(q)$$
- 模型基于\(x\)生成答案，条件概率为：
$$P(y | x) = \prod_{t=1}^{T} P(y_t | y_{<t}, x)$$
- \(y_{<t}\)：第t个token之前的生成序列；\(T\)为生成序列长度。

## 三、实现关键要点（基于论文实验结论）
论文通过多组实验明确QD-RAG的关键实现细节与参数选择，以下为核心要点（论文4.3-4.5节）：

### 1. QD模块的提示设计与子查询数量
- **提示设计**：需明确“拆分后子查询可直接检索”，避免生成模糊子问题（如禁止“三家公司利润对比”类子查询）；
- **子查询数量**：限制最多5个最优——数量过少（≤2个）会遗漏证据维度，过多（≥6个）会引入冗余噪声，且93%以上查询无需超过5个子查询即可覆盖所有证据。

### 2. 重排序模型与检索参数优化
- **重排序模型**：优先选择bge-reranker-large，其在跨领域相关性评估中精度优于同类模型，且推理开销可控；
- **检索阈值k**：固定k=10——k<10会降低证据覆盖，k>10会增加重排序计算成本，且无性能提升。

### 3. 效率优化：子查询缓存策略
- QD模块的LLM推理（16.7s/query）是主要延迟来源，通过缓存“原查询-子查询”映射关系，缓存命中时可跳过QD阶段， latency降至与传统RAG一致（0.03s/query）；
- 重排序阶段虽增加0.88s/query延迟，但相比全量检索噪声过滤的收益可忽略成本。

### 4. 适用场景与边界
- **适用场景**：多跳推理（HotpotQA）、多实体对比（MultiHop-RAG）等复杂查询任务，单跳简单查询无需启用QD模块；
- **边界限制**：原查询已足够精准时（如“梵高的《星空》创作于哪一年？”），QD可能引入噪声，需通过查询复杂度判断是否启用。

## 四、论文实验验证与结果
论文通过两类多跳基准数据集、四组基线对比，验证QD-RAG的有效性，以下为关键实验信息（论文4-5节）：

### 1. 实验设置
- **数据集**：
  - MultiHop-RAG：专注多跳RAG任务，含 gold 证据标注，评估检索指标；
  - HotpotQA：通用多跳QA基准，评估答案准确率与支持事实预测精度；
- **基线对比**：
  - Naive RAG：单查询检索，无QD与重排序；
  - RAG+QD：仅拆分查询，无重排序；
  - RAG+Reranker：单查询检索+重排序；
- **评估指标**：检索类（Hits@4/10、MAP@10、MRR@10）、答案类（EM、F1、Precision、Recall）。

### 2. 核心实验结果
#### （1）主任务性能（表1、表2）
QD-RAG（QD+Reranking）在所有指标中显著优于基线：
| 数据集         | 评估指标   | 次优基线（RAG+Reranker） | QD-RAG | 提升幅度 |
|----------------|------------|--------------------------|--------|----------|
| MultiHop-RAG   | MRR@10     | 0.574                    | 0.635  | +36.7%   |
| MultiHop-RAG   | Hits@10    | 0.781                    | 0.872  | +11.6%   |
| HotpotQA（dev）| 答案F1     | 32.9                     | 35.0   | +6.4%    |
| HotpotQA（dev）| 支持事实Precision | 44.9               | 46.8   | +4.2%    |
**关键原因**：QD模块扩大了证据覆盖，重排序模块过滤了子查询引入的噪声，二者协同解决“覆盖不足”与“噪声过多”的矛盾。

#### （2）消融实验（表1、表2）
验证QD与Reranking的互补作用：
- 仅QD（RAG+QD）：Hits@10提升3.7%，但答案F1仅提升3.2%，因引入噪声；
- 仅Reranking（RAG+Reranker）：MRR@10提升23.7%，但Hits@10无提升，因覆盖不足；
- QD+Reranking：双模块叠加实现性能跃迁，证明协同价值。

#### （3）效率对比（表4）
QD-RAG在性能与效率间实现平衡：
| 方法                | 单查询延迟（s/query） | MultiHop-RAG Hits@10 |
|---------------------|-----------------------|----------------------|
| Naive RAG           | 0.03                  | 0.781                |
| RAG+Reranker        | 0.88                  | 0.781                |
| RAG+QD              | 16.7                  | 0.810                |
| QD-RAG（缓存启用）  | 0.91                  | 0.872                |

## 五、与传统RAG方法的核心差异
论文通过对比传统RAG及变体，明确QD-RAG的创新点，差异如下（论文2.2节、7节）：
| 对比维度               | 传统RAG方法（如Naive RAG、Self-RAG）       | QD-RAG（本文方法）                          |
|------------------------|-------------------------------------------|-------------------------------------------|
| 多跳查询处理           | 单查询检索，证据覆盖不足（分散于多文档）   | 子查询拆分+聚合，覆盖全量证据维度          |
| 噪声控制策略           | 无专门降噪（Naive RAG）或全token校准（高开销） | 重排序精准过滤子查询噪声，开销可控        |
| 训练需求               | 部分需大量任务特定数据（如Self-RAG需14.5万条） | 零训练成本，QD与重排序均为即插即用模块    |
| 泛化性                 | 弱（依赖任务模板）                         | 强（适配所有多跳/复杂查询场景）            |
| MultiHop-RAG MRR@10    | 0.464（Naive RAG）                         | 0.635（提升36.7个百分点）                  |

## 六、总结
QD-RAG作为问题分解增强的RAG框架，通过“QD模块扩覆盖+Reranking模块提精度”，解决了传统RAG在多跳场景下的两大核心痛点：
1. **检索层面**：子查询拆分解决证据分散问题，Hits@10提升11.6%，多跳任务覆盖度显著优于单查询检索；
2. **生成层面**：跨编码器重排序过滤冗余噪声，答案F1提升6.4%，同时通过缓存策略控制延迟开销。

实验表明，QD-RAG在多跳QA基准中实现检索与生成性能双提升，且无需任务特定训练、适配现有RAG架构，为复杂查询场景的RAG优化提供了“模块化增强”的新范式，具备极强的工程落地价值。

